---
title: "Simulation Analysis"
author: "Tzu-Yao Lin"
date: last-modified
bibliography: references.bib
csl: apa.csl
execute:
  warning: false
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true
    code-fold: show
    code-tools: true
---

# Simulation procedure

# Simulated data

## Multilevel Measurement Error Vector Autoregressive (1) Model

According to @schuurman2019, the **multilevel MEVAR(1) model** can be written as follows.

-   Level 1 model (within subject)
    -   Observation equation
-   Measurement equation

$$
\begin{pmatrix}y_{1it} \\ y_{2it}\end{pmatrix} = \begin{pmatrix}\mu_{1i} \\ \mu_{2i}\end{pmatrix} + \begin{pmatrix}\theta_{1it} \\ \theta_{2it}\end{pmatrix} + \begin{pmatrix}\epsilon_{1it} \\ \epsilon_{2it}\end{pmatrix}
$$

$$
\begin{pmatrix}\epsilon_{1it} \\ \epsilon_{2it}\end{pmatrix} \sim \mathcal{N} \left(\begin{pmatrix}0 \\ 0\end{pmatrix}, \mathbf{\Sigma}_{\epsilon i} = \begin{pmatrix} \sigma^2_{\epsilon 11i} & \sigma_{\epsilon 12i} \\ \sigma_{\epsilon 12i} & \sigma^2_{\epsilon 22i}\end{pmatrix}\right)
$$

-   State equation (state space model representation)

$$
\begin{pmatrix}\theta_{1it} \\ \theta_{2it}\end{pmatrix} = \begin{pmatrix} \phi_{11i} & \phi_{12i} \\ \phi_{12i} & \phi_{22i} \end{pmatrix} \begin{pmatrix}\theta_{1it-1} \\ \theta_{2it-1}\end{pmatrix} + \begin{pmatrix}\omega_{1it} \\ \omega_{2it}\end{pmatrix}
$$

$$
\begin{pmatrix}\omega_{1it} \\ \omega_{2it}\end{pmatrix} \sim \mathcal{N} \left(\begin{pmatrix}0 \\ 0\end{pmatrix}, \mathbf{\Sigma}_{\omega i}  = \begin{pmatrix} \sigma^2_{\omega 11i} & \sigma_{\omega 12i} \\ \sigma_{\omega 12i} & \sigma^2_{\omega 22i}\end{pmatrix}\right)
$$

-   Level 2 model (between subject)

$$
\boldsymbol{\mu}_i = \begin{pmatrix}\mu_{1 i} \\\mu_{2 i} \end{pmatrix} \sim \mathcal{N} \left(\boldsymbol{\gamma}_\mu = \begin{pmatrix} \gamma_{\mu 1} \\\gamma_{\mu 2} \end{pmatrix}, \boldsymbol{\Psi}_\mu =\begin{pmatrix} \psi_{\mu1}^2 & \psi_{\mu12} \\ \psi_{\mu12} & \psi_{\mu2}^2\end{pmatrix}\right)
$$

$$
vec(\boldsymbol{\Phi}_i) = \begin{pmatrix} \phi_{11i} \\ \phi_{12i} \\ \phi_{21i} \\ \phi_{22i} \end{pmatrix} \sim \mathcal{N} \left(\boldsymbol{\gamma}_{\Phi} = \begin{pmatrix}\gamma_{\phi 11} \\ \gamma_{\phi 12} \\ \gamma_{\phi 21} \\ \gamma_{\phi 22} \end{pmatrix}, \boldsymbol{\boldsymbol{\Psi}}_{\phi} = \begin{pmatrix} \psi_{\phi11}^2 & \psi_{\phi11\phi12} & \psi_{\phi11\phi21} & \psi_{\phi11\phi22} \\ \psi_{\phi11\phi12} & \psi_{\phi12}^2 & \psi_{\phi12\phi21} & \psi_{\phi12\phi22} \\ \psi_{\phi21\phi11} & \psi_{\phi21\phi12} & \psi_{\phi21}^2 & \psi_{\phi21\phi22} \\ \psi_{\phi11\phi22} & \psi_{\phi22\phi12} & \psi_{\phi22\phi21} & \psi_{\phi22}^2 \end{pmatrix} \right)
$$

$$
vec(upp.tri(\mathbf{R}_i)) = \begin{pmatrix}\sigma_{\epsilon_{11 i}}^{2} \\\sigma_{\epsilon_{12 i}} \\\sigma_{\epsilon_{22 i}}^{2}\end{pmatrix} \sim \mathcal{N} \left(\boldsymbol{\gamma}_{\sigma_\epsilon^2} = \begin{pmatrix} \gamma_{\sigma_{\epsilon 11}^{2}} \\\gamma_{\sigma_{\epsilon 12}} \\ \gamma_{\sigma_{\epsilon 22}^{2}} \end{pmatrix}, \boldsymbol{\Psi}_{\boldsymbol{\sigma}_{\epsilon}^{2}} = \begin{pmatrix} \psi_{\sigma_{\epsilon 11}^2} & & 0 \\ & \psi_{\sigma_{\epsilon 12}} & \\ 0 & & \psi_{\sigma_{\epsilon 22}^2}\end{pmatrix}\right)
$$

\$\$ \sigma*{*\omega{11 i}} \sim logN(\gamma*{*\sigma{\omega 11}}, \psi*{*\sigma{\omega 11}}) \\ \sigma*{*\omega{22 i}} \sim logN(\gamma*{*\sigma{\omega 22}}, \psi*{*\sigma{\omega 22}}) \\ \sigma*{*\omega{12 i}} \sim uniform(-1, 1) \\

```{=tex}
\begin{pmatrix} \psi_{\sigma_{\epsilon 11}^2} &  \\ & \psi_{\sigma_{\epsilon 12}}  \end{pmatrix}
```
\sim LKJ(\eta\_\omega) \$\$

where \$\mathbf{\Sigma}*{*\omega i} = \boldsymbol{\tau}{\omega} \times \times \$

## Reliability

-   **Reliability for systematic between-subject difference**

$$
R^B = \frac{\psi^2_\mu}{Var(y)} = \frac{\psi^2_\mu}{\psi^2_\mu + E_{i}[\tau_i]+ \gamma_{\sigma_\epsilon^2}} 
$$

-   **Reliability for within-subject fluctuations**

$$
R_{i}^W = \frac{\tau_i}{Var(y_{i})} = \frac{\tau_i}{\tau_i + \sigma_{\epsilon i}^2}
$$ 

where $\tau_i = \frac{\sigma_{\omega i}^2}{1 - \phi_i^2}$.

## Data generating function and (hyper-)parameter settings

``` r
#| filename: "data_generation.R"

{{< include data_generation.R >}}
```

## Show generated data

```{r}
library(tidyverse)
theme_set(theme_bw())

source("data_generation.R")


gen_data <- generate_ssm_data(N = 50, nT = 50, seed = 1297)

saveRDS(gen_data, "sim_data/data_N50T50S1297.rds")
```

```{r}
plot_data <- tibble(y = gen_data$y) |> 
  mutate(Sub = 1:n(),
         y1 = map(y, ~ .x[1, ]), 
         y2 = map(y, ~ .x[2, ])) |> 
  unnest_longer(y1:y2) |> 
  pivot_longer(y1:y2, names_to = "Var", values_to = "Value") |> 
  mutate(Time = 1:n(), .by = c(Sub, Var))

plot_data
```


```{r}
ggplot(plot_data, aes(x = Time, y = Value, color = Var)) + 
  geom_line() + geom_point() +
  facet_wrap(Sub ~ .) +
  coord_cartesian(ylim = c(0, 100))


ggplot(plot_data, aes(x = Time, y = Value, group = Sub)) +
  geom_line() + #geom_point() +
  facet_wrap(. ~ Var) 


```


```{r}
gen_data$rel_B

gen_data$rel_W
ggplot()
```


# Model fitting by Stan

## Stan codes

```cmdstan
#| filename: "multilevel-univariate-ssm-lkj.stan"

{{< include stan/multilevel-univariate-ssm-lkj.stan >}}
```



```
 for (n in 1:N) {
    mu[n] ~ multi_normal(gamma_mu, Psi_mu);
    to_vector(Phi[n]) ~ multi_normal(gamma_Phi, Psi_Phi);
    
    // tau_R[n] ~ inv_gamma(alpha_tau_R, beta_tau_R);
    // tau_Q[n] ~ inv_gamma(alpha_tau_Q, beta_tau_Q);
    
    tau_R[n] ~ cauchy(0, 2.5);
    tau_Q[n] ~ cauchy(0, 2.5);
    // L_Omega_R[n] ~ lkj_corr_cholesky(eta_R);
    // L_Omega_Q[n] ~ lkj_corr_cholesky(eta_Q);
    L_Omega_R[n] ~ lkj_corr_cholesky(eta_R);
    L_Omega_Q[n] ~ lkj_corr_cholesky(eta_Q);
  }
```

## Fitting
```{r}
#| label: load-packages

# library(lubridate)
# library(tsibble)
library(cmdstanr)
register_knitr_engine(override = FALSE)
library(posterior)
library(bayesplot)
color_scheme_set("brewer-Spectral")
# library(loo)

source("custom_functions.R")
pos_neg_color <- scales::hue_pal()(2)
```

```{r}
#| label: fit-model
#| eval: false

mssm <- cmdstan_model("stan/multilevel_multivariate_ssm_s2019.stan", 
                      )

mssm_data <- lst(N = 10,
                 `T` = 25,
                 # P = 2,
                 y = gen_data$y)


mssm_fit <- mssm$sample(data = mssm_data, 
                        chains = 6, 
                        parallel_chains = 6, 
                        iter_warmup = 4000, 
                        iter_sampling = 4000, 
                        seed = 1294, 
                        refresh = 2000, 
                        show_messages = TRUE, 
                        output_dir = "stan/results/s2019_fully")
```
All 6 chains finished successfully.
Mean chain execution time: 8547.3 seconds.
Total execution time: 9350.1 seconds.


```{r}
source("custom_functions.R")


# mssm_fit2 <- mssm$sample(data = mssm_data, 
#                      chains = 6,
#                      parallel_chains = 6,
#                      iter_warmup = 0,
#                      iter_sampling = 4000,
#                      adapt_engaged = FALSE,
#                      inv_metric = mssm_fit$inv_metric(matrix = FALSE),
#                      step_size = mssm_fit$metadata()$step_size_adaptation,
#                      init = createStanInitsPreviousRun(mssm_fit),
#                      seed = 1295,
#                      refresh = 2000, 
#                      show_messages = TRUE,
#                      save_warmup = TRUE,
#                      output_dir = "stan/results/lkj_partial")
```


## Check the convergence

```{r}
mssm_sum <- mssm_fit$summary()
View(mssm_sum)
```

```{r}
mssm_fit$profiles()
```

```{r}
mssm_fit$draws(variables = "mu", format = "df") %>% 
  select(1:12, .chain, .iteration, .draw) %>% 
  mcmc_trace()
mssm_fit$draws(variables = "Phi", format = "df") %>% 
  select(1:12, .chain, .iteration, .draw) %>% 
  mcmc_trace()
mssm_fit$draws(variables = "Phi", format = "df") %>% 
  select(13:24, .chain, .iteration, .draw) %>% 
  mcmc_trace()
# mssm_fit$draws(variables = "sigma_omega", format = "df") %>% 
#   mcmc_trace()
# mssm_fit$draws(variables = "sigma_epsilon", format = "df") %>% 
#   mcmc_trace()
```



## Results

```{r}

```

